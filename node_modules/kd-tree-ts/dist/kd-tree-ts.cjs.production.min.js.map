{"version":3,"file":"kd-tree-ts.cjs.production.min.js","sources":["../src/kdNode.ts","../src/rect.ts","../src/tools/pq.ts","../src/kdTree.ts","../src/tools/distance.ts"],"sourcesContent":["import { Point2D } from './types/point2d';\n\nexport interface INode {\n  point: Point2D;\n  left: Node;\n  right: Node;\n  parent: Node;\n}\n\nexport type Node = INode | undefined;\n\nclass KDNode implements INode {\n  left: Node;\n  right: Node;\n  parent: Node;\n\n  constructor(public point: Point2D) {}\n\n  toString() {\n    return this.point.toString();\n  }\n}\n\nexport default KDNode;\n","import { Point2D } from './types/point2d';\nimport { Rect2d } from './types/rect2d';\n\nclass Rect {\n  static contains(rect: Rect2d, point: Point2D): boolean {\n    for (let i = 0; i < point.length; i++) {\n      if (point[i] > rect[1][i] || point[i] < rect[0][i]) return false;\n    }\n    return true;\n  }\n\n  static intersects(rectA: Rect2d, rectB: Rect2d): boolean {\n    for (let i = 0; i < rectA[0].length; i++) {\n      if (rectA[0][i] > rectB[1][i] || rectA[1][i] < rectB[0][i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  static clone(rect: Rect2d): Rect2d {\n    return [[...rect[0]], [...rect[1]]];\n  }\n}\n\nexport default Rect;\n","export interface PqItem<T> {\n  value: T;\n  priority: number;\n}\n\nclass PQ<T> {\n  private data: PqItem<T>[] = [];\n  private lessThan(a: PqItem<T>, b: PqItem<T>): boolean {\n    if (!b) return false;\n    return a.priority < b.priority;\n  }\n\n  constructor(readonly capacity: number) {}\n\n  get size(): number {\n    return this.data.length;\n  }\n\n  get values(): T[] {\n    return this.data.map(({ value }) => value);\n  }\n\n  get top(): PqItem<T> {\n    return this.data[0];\n  }\n\n  get maxPriority(): number {\n    return this.data[0] && this.data[0].priority;\n  }\n\n  siftUp(i: number): void {\n    while (\n      i > 0 &&\n      this.lessThan(this.data[Math.floor((i - 1) / 2)], this.data[i])\n    ) {\n      const parent = Math.floor((i - 1) / 2);\n      [this.data[parent], this.data[i]] = [this.data[i], this.data[parent]];\n      i = parent;\n    }\n  }\n\n  siftDown(i: number): void {\n    const n = this.data.length;\n\n    while (i * 2 + 1 < n) {\n      let max = i;\n\n      if (this.lessThan(this.data[max], this.data[i * 2 + 1])) {\n        max = i * 2 + 1;\n      }\n      if (this.lessThan(this.data[max], this.data[i * 2 + 2])) {\n        max = i * 2 + 2;\n      }\n      if (max === i) break;\n\n      [this.data[i], this.data[max]] = [this.data[max], this.data[i]];\n      i = max;\n    }\n  }\n\n  push(value: PqItem<T>) {\n    if (this.capacity > this.size) {\n      this.data.push(value);\n      this.siftUp(this.data.length - 1);\n      return;\n    }\n    if (this.lessThan(this.top, value)) {\n      return;\n    }\n    this.data[0] = value;\n    this.siftDown(0);\n  }\n}\n\nexport default PQ;\n","import KDNode, { Node } from './kdNode';\nimport { Point2D } from './types/point2d';\nimport distance from './tools/distance';\nimport Rect from './rect';\nimport { Rect2d } from './types/rect2d';\nimport PQ from './tools/pq';\n\nclass KDTree {\n  root: Node;\n  constructor(readonly points?: Point2D[], private dimensions: number = 2) {\n    const buildTree = (points: Point2D[] = [], depth = 0, parent?: Node) => {\n      if (!points.length) {\n        return;\n      }\n      const axis = depth % this.dimensions;\n      points.sort((a, b) => a[axis] - b[axis]);\n\n      const median = Math.floor(points.length / 2);\n      const node = new KDNode(points[median]);\n\n      node.parent = parent;\n      node.left = buildTree(points.slice(0, median), axis + 1, node);\n      node.right = buildTree(points.slice(median + 1), axis + 1, node);\n      return node;\n    };\n\n    this.root = buildTree(points);\n  }\n\n  insert(point: Point2D) {\n    if (!this.root) {\n      this.root = new KDNode(point);\n      return this.root;\n    }\n    let node = this.root;\n    let cd = 0;\n    while (node) {\n      if (point[cd] < node.point[cd]) {\n        cd = (cd + 1) % this.dimensions;\n        if (!node.left) {\n          const newNode = new KDNode(point);\n          node.left = newNode;\n          newNode.parent = node;\n          return newNode;\n        }\n        node = node.left;\n      } else {\n        cd = (cd + 1) % this.dimensions;\n        if (!node.right) {\n          const newNode = new KDNode(point);\n          node.right = newNode;\n          newNode.parent = node;\n          return newNode;\n        }\n        node = node.right;\n      }\n    }\n    return node;\n  }\n\n  nearest(point: Point2D, k: number = 1) {\n    const nearest = new PQ<Point2D>(k);\n\n    const distanceToBb = (point: Point2D, bB: KDNode, cd: number): number => {\n      return Math.abs(bB.point[cd] - point[cd]);\n    };\n\n    const search = (point: Point2D, node: Node, cd: number): void => {\n      if (!node) {\n        return;\n      }\n      const curDist = distance(point, node.point);\n      nearest.push({ value: node.point, priority: curDist });\n\n      let first, last;\n      if (point[cd] < node.point[cd]) {\n        first = node.left;\n        last = node.right;\n      } else {\n        first = node.right;\n        last = node.left;\n      }\n\n      search(point, first, (cd + 1) % this.dimensions);\n      const distToBb = distanceToBb(point, node, cd);\n      if (nearest.size < nearest.capacity || distToBb < nearest.maxPriority) {\n        search(point, last, (cd + 1) % this.dimensions);\n      }\n    };\n\n    search(point, this.root, 0);\n\n    return nearest.values;\n  }\n\n  rangeSearch(rect: Rect2d): Point2D[] | [] {\n    const result: Point2D[] = [];\n\n    if (!this.root) {\n      return result;\n    }\n\n    const search = (\n      node: Node,\n      box: Rect2d = [\n        [-Infinity, -Infinity],\n        [Infinity, Infinity],\n      ],\n      cd: number = 0\n    ): void => {\n      if (node === undefined) {\n        return;\n      }\n      const { point } = node;\n      if (Rect.contains(rect, node.point)) {\n        result.push(point);\n      }\n      const leftBox: Rect2d = Rect.clone(box);\n      leftBox[1][cd] = point[cd];\n      const rightBox: Rect2d = Rect.clone(box);\n      rightBox[0][cd] = point[cd];\n\n      cd = (cd + 1) % this.dimensions;\n      if (Rect.intersects(leftBox, rect)) {\n        search(node.left, leftBox, cd);\n      }\n      if (Rect.intersects(rightBox, rect)) {\n        search(node.right, rightBox, cd);\n      }\n    };\n\n    search(this.root);\n\n    return result;\n  }\n}\n\nexport default KDTree;\n","import { Point2D } from '../types/point2d';\n\nfunction distance(a: Point2D, b: Point2D): number {\n  return Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2));\n}\n\nexport default distance;\n"],"names":["KDNode","point","toString","this","Rect","contains","rect","i","length","intersects","rectA","rectB","clone","PQ","capacity","lessThan","a","b","priority","siftUp","data","Math","floor","parent","siftDown","n","max","push","value","size","top","map","points","dimensions","root","buildTree","depth","axis","_this","sort","median","node","left","slice","right","insert","cd","newNode","nearest","k","search","first","last","curDist","sqrt","pow","_this2","distToBb","bB","abs","distanceToBb","maxPriority","values","rangeSearch","result","box","Infinity","undefined","leftBox","rightBox","_this3"],"mappings":"wEAWMA,wBAKeC,cAAAA,qBAEnBC,SAAA,kBACSC,KAAKF,MAAMC,iBChBhBE,oCACGC,SAAP,SAAgBC,EAAcL,OACvB,IAAIM,EAAI,EAAGA,EAAIN,EAAMO,OAAQD,OAC5BN,EAAMM,GAAKD,EAAK,GAAGC,IAAMN,EAAMM,GAAKD,EAAK,GAAGC,GAAI,OAAO,SAEtD,KAGFE,WAAP,SAAkBC,EAAeC,OAC1B,IAAIJ,EAAI,EAAGA,EAAIG,EAAM,GAAGF,OAAQD,OAC/BG,EAAM,GAAGH,GAAKI,EAAM,GAAGJ,IAAMG,EAAM,GAAGH,GAAKI,EAAM,GAAGJ,UAC/C,SAGJ,KAGFK,MAAP,SAAaN,SACJ,WAAKA,EAAK,cAASA,EAAK,WChB7BO,wBAOiBC,iBAAAA,YANO,gCACpBC,SAAA,SAASC,EAAcC,WACxBA,GACED,EAAEE,SAAWD,EAAEC,YAqBxBC,OAAA,SAAOZ,QAEHA,EAAI,GACJJ,KAAKY,SAASZ,KAAKiB,KAAKC,KAAKC,OAAOf,EAAI,GAAK,IAAKJ,KAAKiB,KAAKb,KAC5D,KACMgB,EAASF,KAAKC,OAAOf,EAAI,GAAK,KACA,CAACJ,KAAKiB,KAAKb,GAAIJ,KAAKiB,KAAKG,SAAvDH,KAAKG,aAAcH,KAAKb,QAC9BA,EAAIgB,MAIRC,SAAA,SAASjB,WACDkB,EAAItB,KAAKiB,KAAKZ,OAET,EAAJD,EAAQ,EAAIkB,GAAG,KAChBC,EAAMnB,KAENJ,KAAKY,SAASZ,KAAKiB,KAAKM,GAAMvB,KAAKiB,KAAS,EAAJb,EAAQ,MAClDmB,EAAU,EAAJnB,EAAQ,GAEZJ,KAAKY,SAASZ,KAAKiB,KAAKM,GAAMvB,KAAKiB,KAAS,EAAJb,EAAQ,MAClDmB,EAAU,EAAJnB,EAAQ,GAEZmB,IAAQnB,EAAG,YAEkB,CAACJ,KAAKiB,KAAKM,GAAMvB,KAAKiB,KAAKb,SAAtDa,KAAKb,aAASa,KAAKM,QACzBnB,EAAImB,MAIRC,KAAA,SAAKC,MACCzB,KAAKW,SAAWX,KAAK0B,iBAClBT,KAAKO,KAAKC,aACVT,OAAOhB,KAAKiB,KAAKZ,OAAS,GAG7BL,KAAKY,SAASZ,KAAK2B,IAAKF,UAGvBR,KAAK,GAAKQ,OACVJ,SAAS,2CAvDPrB,KAAKiB,KAAKZ,6CAIVL,KAAKiB,KAAKW,KAAI,qBAAGH,4CAIjBzB,KAAKiB,KAAK,8CAIVjB,KAAKiB,KAAK,IAAMjB,KAAKiB,KAAK,GAAGF,6OClBjBc,EAA4BC,uBAAAA,IAAAA,EAAqB,eAAjDD,kBAA4BC,OAiB1CC,KAhBa,SAAZC,EAAaH,EAAwBI,EAAWb,eAAnCS,IAAAA,EAAoB,aAAII,IAAAA,EAAQ,GAC5CJ,EAAOxB,YAGN6B,EAAOD,EAAQE,EAAKL,WAC1BD,EAAOO,MAAK,SAACvB,EAAGC,UAAMD,EAAEqB,GAAQpB,EAAEoB,UAE5BG,EAASnB,KAAKC,MAAMU,EAAOxB,OAAS,GACpCiC,EAAO,IAAIzC,EAAOgC,EAAOQ,WAE/BC,EAAKlB,OAASA,EACdkB,EAAKC,KAAOP,EAAUH,EAAOW,MAAM,EAAGH,GAASH,EAAO,EAAGI,GACzDA,EAAKG,MAAQT,EAAUH,EAAOW,MAAMH,EAAS,GAAIH,EAAO,EAAGI,GACpDA,GAGGN,CAAUH,8BAGxBa,OAAA,SAAO5C,OACAE,KAAK+B,iBACHA,KAAO,IAAIlC,EAAOC,GAChBE,KAAK+B,aAEVO,EAAOtC,KAAK+B,KACZY,EAAK,EACFL,MACDxC,EAAM6C,GAAML,EAAKxC,MAAM6C,GAAK,IAC9BA,GAAMA,EAAK,GAAK3C,KAAK8B,YAChBQ,EAAKC,KAAM,KACRK,EAAU,IAAI/C,EAAOC,UAC3BwC,EAAKC,KAAOK,EACZA,EAAQxB,OAASkB,EACVM,EAETN,EAAOA,EAAKC,SACP,IACLI,GAAMA,EAAK,GAAK3C,KAAK8B,YAChBQ,EAAKG,MAAO,KACTG,EAAU,IAAI/C,EAAOC,UAC3BwC,EAAKG,MAAQG,EACbA,EAAQxB,OAASkB,EACVM,EAETN,EAAOA,EAAKG,aAGTH,KAGTO,QAAA,SAAQ/C,EAAgBgD,uBAAAA,IAAAA,EAAY,OAC5BD,EAAU,IAAInC,EAAYoC,UAMjB,SAATC,EAAUjD,EAAgBwC,EAAYK,MACrCL,OClEOzB,EAAYC,EDwEpBkC,EAAOC,EAHLC,GCrEMrC,EDqEaf,ECrEDgB,EDqEQwB,EAAKxC,MCpElCoB,KAAKiC,KAAKjC,KAAKkC,IAAIvC,EAAE,GAAKC,EAAE,GAAI,GAAKI,KAAKkC,IAAIvC,EAAE,GAAKC,EAAE,GAAI,KDqE9D+B,EAAQrB,KAAK,CAAEC,MAAOa,EAAKxC,MAAOiB,SAAUmC,IAGxCpD,EAAM6C,GAAML,EAAKxC,MAAM6C,IACzBK,EAAQV,EAAKC,KACbU,EAAOX,EAAKG,QAEZO,EAAQV,EAAKG,MACbQ,EAAOX,EAAKC,MAGdQ,EAAOjD,EAAOkD,GAAQL,EAAK,GAAKU,EAAKvB,gBAC/BwB,EArBa,SAACxD,EAAgByD,EAAYZ,UACzCzB,KAAKsC,IAAID,EAAGzD,MAAM6C,GAAM7C,EAAM6C,IAoBpBc,CAAa3D,EAAOwC,EAAMK,IACvCE,EAAQnB,KAAOmB,EAAQlC,UAAY2C,EAAWT,EAAQa,cACxDX,EAAOjD,EAAOmD,GAAON,EAAK,GAAKU,EAAKvB,aAIxCiB,CAAOjD,EAAOE,KAAK+B,KAAM,GAElBc,EAAQc,UAGjBC,YAAA,SAAYzD,cACJ0D,EAAoB,UAErB7D,KAAK+B,MAIK,SAATgB,EACJT,EACAwB,EAIAnB,eAJAmB,IAAAA,EAAc,CACZ,EAAEC,UAAWA,UACb,CAACA,SAAUA,qBAEbpB,IAAAA,EAAa,QAEAqB,IAAT1B,OAGIxC,EAAUwC,EAAVxC,MACJG,EAAKC,SAASC,EAAMmC,EAAKxC,QAC3B+D,EAAOrC,KAAK1B,OAERmE,EAAkBhE,EAAKQ,MAAMqD,GACnCG,EAAQ,GAAGtB,GAAM7C,EAAM6C,OACjBuB,EAAmBjE,EAAKQ,MAAMqD,GACpCI,EAAS,GAAGvB,GAAM7C,EAAM6C,GAExBA,GAAMA,EAAK,GAAKwB,EAAKrC,WACjB7B,EAAKK,WAAW2D,EAAS9D,IAC3B4C,EAAOT,EAAKC,KAAM0B,EAAStB,GAEzB1C,EAAKK,WAAW4D,EAAU/D,IAC5B4C,EAAOT,EAAKG,MAAOyB,EAAUvB,IAIjCI,CAAO/C,KAAK+B,MAEL8B,GAlCEA"}