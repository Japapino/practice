'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var KDNode = /*#__PURE__*/function () {
  function KDNode(point) {
    this.point = point;
  }

  var _proto = KDNode.prototype;

  _proto.toString = function toString() {
    return this.point.toString();
  };

  return KDNode;
}();

function distance(a, b) {
  return Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2));
}

var Rect = /*#__PURE__*/function () {
  function Rect() {}

  Rect.contains = function contains(rect, point) {
    for (var i = 0; i < point.length; i++) {
      if (point[i] > rect[1][i] || point[i] < rect[0][i]) return false;
    }

    return true;
  };

  Rect.intersects = function intersects(rectA, rectB) {
    for (var i = 0; i < rectA[0].length; i++) {
      if (rectA[0][i] > rectB[1][i] || rectA[1][i] < rectB[0][i]) {
        return false;
      }
    }

    return true;
  };

  Rect.clone = function clone(rect) {
    return [[].concat(rect[0]), [].concat(rect[1])];
  };

  return Rect;
}();

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var PQ = /*#__PURE__*/function () {
  function PQ(capacity) {
    this.capacity = capacity;
    this.data = [];
  }

  var _proto = PQ.prototype;

  _proto.lessThan = function lessThan(a, b) {
    if (!b) return false;
    return a.priority < b.priority;
  };

  _proto.siftUp = function siftUp(i) {
    while (i > 0 && this.lessThan(this.data[Math.floor((i - 1) / 2)], this.data[i])) {
      var parent = Math.floor((i - 1) / 2);
      var _ref = [this.data[i], this.data[parent]];
      this.data[parent] = _ref[0];
      this.data[i] = _ref[1];
      i = parent;
    }
  };

  _proto.siftDown = function siftDown(i) {
    var n = this.data.length;

    while (i * 2 + 1 < n) {
      var max = i;

      if (this.lessThan(this.data[max], this.data[i * 2 + 1])) {
        max = i * 2 + 1;
      }

      if (this.lessThan(this.data[max], this.data[i * 2 + 2])) {
        max = i * 2 + 2;
      }

      if (max === i) break;
      var _ref2 = [this.data[max], this.data[i]];
      this.data[i] = _ref2[0];
      this.data[max] = _ref2[1];
      i = max;
    }
  };

  _proto.push = function push(value) {
    if (this.capacity > this.size) {
      this.data.push(value);
      this.siftUp(this.data.length - 1);
      return;
    }

    if (this.lessThan(this.top, value)) {
      return;
    }

    this.data[0] = value;
    this.siftDown(0);
  };

  _createClass(PQ, [{
    key: "size",
    get: function get() {
      return this.data.length;
    }
  }, {
    key: "values",
    get: function get() {
      return this.data.map(function (_ref3) {
        var value = _ref3.value;
        return value;
      });
    }
  }, {
    key: "top",
    get: function get() {
      return this.data[0];
    }
  }, {
    key: "maxPriority",
    get: function get() {
      return this.data[0] && this.data[0].priority;
    }
  }]);

  return PQ;
}();

var KDTree = /*#__PURE__*/function () {
  function KDTree(points, dimensions) {
    var _this = this;

    if (dimensions === void 0) {
      dimensions = 2;
    }

    this.points = points;
    this.dimensions = dimensions;

    var buildTree = function buildTree(points, depth, parent) {
      if (points === void 0) {
        points = [];
      }

      if (depth === void 0) {
        depth = 0;
      }

      if (!points.length) {
        return;
      }

      var axis = depth % _this.dimensions;
      points.sort(function (a, b) {
        return a[axis] - b[axis];
      });
      var median = Math.floor(points.length / 2);
      var node = new KDNode(points[median]);
      node.parent = parent;
      node.left = buildTree(points.slice(0, median), axis + 1, node);
      node.right = buildTree(points.slice(median + 1), axis + 1, node);
      return node;
    };

    this.root = buildTree(points);
  }

  var _proto = KDTree.prototype;

  _proto.insert = function insert(point) {
    if (!this.root) {
      this.root = new KDNode(point);
      return this.root;
    }

    var node = this.root;
    var cd = 0;

    while (node) {
      if (point[cd] < node.point[cd]) {
        cd = (cd + 1) % this.dimensions;

        if (!node.left) {
          var newNode = new KDNode(point);
          node.left = newNode;
          newNode.parent = node;
          return newNode;
        }

        node = node.left;
      } else {
        cd = (cd + 1) % this.dimensions;

        if (!node.right) {
          var _newNode = new KDNode(point);

          node.right = _newNode;
          _newNode.parent = node;
          return _newNode;
        }

        node = node.right;
      }
    }

    return node;
  };

  _proto.nearest = function nearest(point, k) {
    var _this2 = this;

    if (k === void 0) {
      k = 1;
    }

    var nearest = new PQ(k);

    var distanceToBb = function distanceToBb(point, bB, cd) {
      return Math.abs(bB.point[cd] - point[cd]);
    };

    var search = function search(point, node, cd) {
      if (!node) {
        return;
      }

      var curDist = distance(point, node.point);
      nearest.push({
        value: node.point,
        priority: curDist
      });
      var first, last;

      if (point[cd] < node.point[cd]) {
        first = node.left;
        last = node.right;
      } else {
        first = node.right;
        last = node.left;
      }

      search(point, first, (cd + 1) % _this2.dimensions);
      var distToBb = distanceToBb(point, node, cd);

      if (nearest.size < nearest.capacity || distToBb < nearest.maxPriority) {
        search(point, last, (cd + 1) % _this2.dimensions);
      }
    };

    search(point, this.root, 0);
    return nearest.values;
  };

  _proto.rangeSearch = function rangeSearch(rect) {
    var _this3 = this;

    var result = [];

    if (!this.root) {
      return result;
    }

    var search = function search(node, box, cd) {
      if (box === void 0) {
        box = [[-Infinity, -Infinity], [Infinity, Infinity]];
      }

      if (cd === void 0) {
        cd = 0;
      }

      if (node === undefined) {
        return;
      }

      var point = node.point;

      if (Rect.contains(rect, node.point)) {
        result.push(point);
      }

      var leftBox = Rect.clone(box);
      leftBox[1][cd] = point[cd];
      var rightBox = Rect.clone(box);
      rightBox[0][cd] = point[cd];
      cd = (cd + 1) % _this3.dimensions;

      if (Rect.intersects(leftBox, rect)) {
        search(node.left, leftBox, cd);
      }

      if (Rect.intersects(rightBox, rect)) {
        search(node.right, rightBox, cd);
      }
    };

    search(this.root);
    return result;
  };

  return KDTree;
}();

exports.default = KDTree;
//# sourceMappingURL=kd-tree-ts.cjs.development.js.map
